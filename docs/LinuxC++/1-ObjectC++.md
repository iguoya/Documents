# 面向对象的C++

## 面向对象的特点

1. 抽象
2. 封装
3. 继承
4. 多态



## 类与对象

### 声明和定义

## 访问控制

| 类属性\类成员 | Public | protected | private |
| ------------- | ------ | --------- | ------- |
| public        | d      |           | N N     |
| protected     | Y      |           |         |
| private       | Y      |           |         |

保护成员和私有成员性质相似,区别在于对子类成员影响的不同

## 成员函数

### 实现

### 调用对象

### this

### 内联



## 对象的构造

### 默认构造函数

``` c++
class Point {
  int x;
  int y;
  Point(){};
  Point(int a, int b){
    x = a;
    y = b;
  };
}

```

### 复制构造函数

形参是对象的引用

``` c++
Point(const Point &p);
```

1. 浅拷贝

   ``` c++

   > 

2. 深拷贝

  > 复制重新生成指针指向的对象

### 构造函数的初始化列表

``` c++
A::A(int x, int y): x(a), y(b){
  // x = a;省略
  // y = b;
} 
```

1. 构造对象时,同步构造内部对象

2. 部分成员(常量/引用) 只能初始化,不能赋值

3. 部分成员(类的对象)如果赋值,,将导致二次构造

   > 在分配内存时,调用缺省构造函数构造函数构造,然后执行构造函数的赋值语句构造,效率不佳
   >
   > 如果类没有却省构造函数,将导致问题

4. 成员初始化按照成员定义顺序
5.  **必须保持初始化列表和成员定义的顺序一致性**,允许跳过成员初始化

## 对象的析构

在对象生命期结束时清除它, 用于**释放动态分配内存的目标的数据对象**

``` c++
~Point(){}; 
```



1. 无返回值类型

2. 析构函数必须公开

3. 可以由系统销毁,也可以程序直接调用主动调用

4. 只有一个析构函数

   ``` c++
   class A {
     A(int x);
     ~A();
     int *p;
   }
   
   //实现
   A::A(int x) {
     p = new int(x);
   }
   
   A::~A() {
     delete p;
   }
   ```

   

## 对象的数组

